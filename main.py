N=2351836781199061294834615894763937853852277281725622831
e=65537
d=642496387240612072916352028940226709076344784031488897949235920941130777044396693964606757677718709430727468
c=949235920941130777044396693964606757677718709430727468

m=pow(c, d)%N

print(m)


# # Заданные значения
# e = 65537
# phi_N = 2351836781199061294834615891457531156877592052673798472  # Функция Эйлера от N

# # Функция для нахождения мультипликативно обратного элемента
# def mod_inverse(e, phi_N):
#     x0, x1, y0, y1 = 1, 0, 0, 1
#     a, b = e, phi_N
#     while b != 0:
#         q, a, b = a // b, b, a % b
#         x0, x1 = x1, x0 - q * x1
#         y0, y1 = y1, y0 - q * y1
#     d = x0
#     if d < 0:
#         d += phi_N
#     return d

# # Вычисление закрытого ключа d
# d = mod_inverse(e, phi_N)

# print("Закрытый ключ (d):", d)